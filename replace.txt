0 js/main.js
382
function startVideo() {
  console.log('[Video] Starting video');
  
  // Remove any existing local video first to avoid duplicates
  const existingContainer = document.querySelector('#localVideoContainer');
  if (existingContainer) {
    existingContainer.remove();
  }
  
  // Get video stream - either reuse existing or create new
  const getVideo = videoStream ? Promise.resolve(videoStream) : navigator.mediaDevices.getUserMedia({ 
    video: { 
      width: { ideal: 640 }, 
      height: { ideal: 360 },
      facingMode: "user"
    } 
  });
  
  getVideo
    .then(stream => {
      if (!videoStream) videoStream = stream;
      isVideoEnabled = true;
      
      const voiceUsersDisplay = document.getElementById('voiceUsersDisplay');
      if (!voiceUsersDisplay) {
        console.error('[Video] voiceUsersDisplay not found');
        return;
      }
      
      // Create video container with proper styling
      const videoContainer = document.createElement('div');
      videoContainer.id = 'localVideoContainer';
      videoContainer.className = 'voice-participant';
      videoContainer.style.display = 'flex';
      videoContainer.style.flexDirection = 'column';
      videoContainer.style.alignItems = 'center';
      videoContainer.style.margin = '8px';
      
      // CRITICAL: Create video element with ALL required attributes for autoplay
      const videoWrapper = document.createElement('div');
      videoWrapper.className = 'voice-participant-avatar';
      videoWrapper.style.width = '80px';
      videoWrapper.style.height = '80px';
      videoWrapper.style.borderRadius = '50%';
      videoWrapper.style.overflow = 'hidden';
      videoWrapper.style.background = '#000';
      videoWrapper.style.position = 'relative';
      
      const video = document.createElement('video');
      video.id = 'localVideo';
      video.autoplay = true;
      video.playsInline = true; // Critical for iOS
      video.muted = true; // Must be muted for autoplay
      video.style.width = '100%';
      video.style.height = '100%';
      video.style.objectFit = 'cover';
      video.style.transform = 'scaleX(-1)'; // Mirror effect
      
      videoWrapper.appendChild(video);
      videoContainer.appendChild(videoWrapper);
      
      const nameLabel = document.createElement('div');
      nameLabel.className = 'voice-participant-name';
      nameLabel.textContent = userProfile.username + ' (You)';
      nameLabel.style.marginTop = '4px';
      videoContainer.appendChild(nameLabel);
      
      voiceUsersDisplay.appendChild(videoContainer);
      
      // Attach stream and force play
      video.srcObject = videoStream;
      
      // Multiple strategies to ensure video plays
      const forcePlay = () => {
        video.play()
          .then(() => console.log('[Video] Playing successfully'))
          .catch(err => {
            console.warn('[Video] Play failed, retrying:', err);
            // Retry on user interaction
            const clickHandler = () => {
              video.play();
              document.removeEventListener('click', clickHandler);
            };
            document.addEventListener('click', clickHandler, { once: true });
          });
      };
      
      // Try playing immediately and on metadata load
      video.onloadedmetadata = () => {
        console.log('[Video] Metadata loaded, dimensions:', video.videoWidth, 'x', video.videoHeight);
        forcePlay();
      };
      
      // Also try after a short delay (helps with some browsers)
      setTimeout(forcePlay, 50);
      setTimeout(forcePlay, 250);
      
      // Add video track to existing peer connections
      const videoTrack = videoStream.getVideoTracks()[0];
      if (videoTrack) {
        Object.keys(peerConnections).forEach(otherUid => {
          const pc = peerConnections[otherUid];
          if (pc) {
            // Check if we already have a video sender
            const existingSender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
            if (!existingSender) {
              try {
                pc.addTrack(videoTrack, videoStream);
                console.log('[WebRTC] Added video track to:', otherUid);
              } catch (e) {
                console.error('[WebRTC] Error adding track:', e);
              }
            }
          }
        });
      }
      
      console.log('[Video] Video started successfully');
    })
    .catch(error => {
      console.error('[Video] Error starting video:', error);
      isVideoEnabled = false;
      showToast('Camera access is required to enable video', 'error');
    });
}
550
function stopVideo() {
  console.log('[Video] Stopping video');
  
  if (videoStream) {
    // Stop video tracks
    const videoTracks = videoStream.getVideoTracks();
    videoTracks.forEach(track => {
      track.stop();
      
      // Remove from peer connections
      Object.keys(peerConnections).forEach(otherUid => {
        const pc = peerConnections[otherUid];
        if (pc) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
          if (sender) {
            try {
              pc.removeTrack(sender);
              console.log('[WebRTC] Removed video track from:', otherUid);
            } catch (e) {
              console.error('[WebRTC] Error removing track:', e);
            }
          }
        }
      });
    });
    
    // Handle audio - keep if in voice channel
    const audioTracks = videoStream.getAudioTracks();
    if (audioTracks.length > 0) {
      if (!inVoiceChannel) {
        // Stop all tracks if not in voice
        audioTracks.forEach(track => track.stop());
        videoStream = null;
        localStream = null;
      } else {
        // Keep audio for voice chat
        if (!localStream || localStream.getAudioTracks().length === 0) {
          localStream = new MediaStream(audioTracks);
        }
        // Stop only video tracks, keep audio
        videoStream = null;
      }
    } else {
      videoStream = null;
    }
  }
  
  isVideoEnabled = false;
  
  // Remove video element from DOM
  const localContainer = document.querySelector('#localVideoContainer');
  if (localContainer) {
    localContainer.remove();
  }
  
  console.log('[Video] Video stopped');
}
620
function establishPeerConnection(otherUid) {
  console.log('[WebRTC] Establishing connection with:', otherUid);
  
  if (peerConnections[otherUid]) {
    console.log('[WebRTC] Already connected to:', otherUid);
    return;
  }

  const pc = new RTCPeerConnection(STUN_SERVERS);
  peerConnections[otherUid] = pc;
  peerCandidates[otherUid] = [];
  
  // Collect all tracks to add
  const tracksToAdd = [];
  
  // Add audio from localStream
  if (localStream) {
    localStream.getTracks().forEach(track => {
      if (!tracksToAdd.find(t => t.kind === track.kind)) {
        tracksToAdd.push({ track, stream: localStream });
      }
    });
  }
  
  // Add video from videoStream
  if (videoStream && isVideoEnabled) {
    videoStream.getVideoTracks().forEach(track => {
      if (!tracksToAdd.find(t => t.kind === 'video')) {
        tracksToAdd.push({ track, stream: videoStream });
      }
    });
  }
  
  // Add tracks to peer connection
  tracksToAdd.forEach(({ track, stream }) => {
    try {
      pc.addTrack(track, stream);
      console.log('[WebRTC] Added', track.kind, 'track for:', otherUid);
    } catch (e) {
      console.error('[WebRTC] Error adding track:', e);
    }
  });
  
  // Handle ICE candidates
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      db.ref(`servers/${currentServer}/voiceChannels/${currentVoiceChannel}/signals/iceCandidates/${currentUser.uid}/${otherUid}`).push({
        candidate: e.candidate.candidate,
        sdpMid: e.candidate.sdpMid,
        sdpMLineIndex: e.candidate.sdpMLineIndex,
        timestamp: Date.now()
      });
    }
  };
  
  // Handle incoming tracks - FIXED for video display
  pc.ontrack = (e) => {
    console.log('[WebRTC] Received', e.track.kind, 'from:', otherUid);
    
    const stream = e.streams[0];
    if (!stream) {
      console.error('[WebRTC] No stream in track event');
      return;
    }
    
    if (e.track.kind === 'video') {
      // Small delay to ensure DOM element exists
      setTimeout(() => {
        const remoteVideo = document.getElementById(`remoteVideo-${otherUid}`);
        if (remoteVideo) {
          // CRITICAL: Set srcObject and force play
          remoteVideo.srcObject = stream;
          
          const playRemote = () => {
            remoteVideo.play()
              .then(() => console.log('[WebRTC] Remote video playing:', otherUid))
              .catch(err => {
                console.warn('[WebRTC] Remote video autoplay blocked:', err);
                document.addEventListener('click', () => remoteVideo.play(), { once: true });
              });
          };
          
          // Try multiple times
          playRemote();
          remoteVideo.onloadedmetadata = playRemote;
          setTimeout(playRemote, 100);
          
          // Handle track events
          e.track.onunmute = () => {
            console.log('[WebRTC] Remote video unmuted:', otherUid);
            remoteVideo.play().catch(console.error);
          };
          
          e.track.onmute = () => {
            console.log('[WebRTC] Remote video muted:', otherUid);
          };
          
          // Check if track is already unmuted
          if (!e.track.muted) {
            playRemote();
          }
        } else {
          console.warn('[WebRTC] No video element for:', otherUid);
        }
      }, 50);
      
    } else if (e.track.kind === 'audio') {
      // Create or update audio element
      let remoteAudio = document.getElementById(`remoteAudio-${otherUid}`);
      if (!remoteAudio) {
        remoteAudio = document.createElement('audio');
        remoteAudio.id = `remoteAudio-${otherUid}`;
        remoteAudio.autoplay = true;
        remoteAudio.style.display = 'none';
        document.body.appendChild(remoteAudio);
      }
      
      remoteAudio.srcObject = stream;
      remoteAudio.muted = false;
      
      // Force play audio
      const playAudio = () => {
        remoteAudio.play()
          .then(() => console.log('[WebRTC] Remote audio playing:', otherUid))
          .catch(err => console.warn('[WebRTC] Audio autoplay blocked:', err));
      };
      
      playAudio();
      setTimeout(playAudio, 100);
      
      e.track.onunmute = playAudio;
    }
  };
  
  pc.onconnectionstatechange = () => {
    console.log('[WebRTC] Connection state:', otherUid, '-', pc.connectionState);
    if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
      cleanupPeerConnection(otherUid);
    }
  };
  
  // Determine who creates offer (lower UID calls)
  const shouldCreateOffer = currentUser.uid < otherUid;
  
  if (shouldCreateOffer) {
    setupCaller(pc, otherUid);
  } else {
    setupCallee(pc, otherUid);
  }
}
800
function setupVoiceUsersListener(channelName) {
  db.ref(`servers/${currentServer}/voiceChannels/${channelName}/users`).on('value', snapshot => {
    const users = snapshot.val() || {};
    
    // Clear display but keep track of existing elements to avoid recreation
    const existingParticipants = new Set();
    document.querySelectorAll('.voice-participant').forEach(el => {
      const id = el.id;
      if (id && id.startsWith('participant-')) {
        existingParticipants.add(id.replace('participant-', ''));
      }
    });
    
    // Remove participants who left
    existingParticipants.forEach(uid => {
      if (!users[uid] && uid !== currentUser.uid) {
        const el = document.getElementById(`participant-${uid}`);
        if (el) el.remove();
        if (peerConnections[uid]) {
          cleanupPeerConnection(uid);
        }
      }
    });
    
    // Add or update participants
    Object.entries(users).forEach(([uid, userData]) => {
      if (uid === currentUser.uid) return;
      
      let div = document.getElementById(`participant-${uid}`);
      
      // Create new element if doesn't exist
      if (!div) {
        div = document.createElement('div');
        div.className = 'voice-participant';
        div.id = `participant-${uid}`;
        div.style.display = 'flex';
        div.style.flexDirection = 'column';
        div.style.alignItems = 'center';
        div.style.margin = '8px';
      }
      
      // Update content based on video status
      if (userData.videoEnabled) {
        // Only recreate if not already video
        if (!div.querySelector('video')) {
          div.innerHTML = `
            <div class="voice-participant-avatar" style="width: 80px; height: 80px; border-radius: 50%; overflow: hidden; background: #000;">
              <video 
                id="remoteVideo-${uid}" 
                autoplay 
                playsinline
                webkit-playsinline
                style="width: 100%; height: 100%; object-fit: cover;"
              ></video>
            </div>
            <div class="voice-participant-name" style="margin-top: 4px;">${userData.username || 'Unknown'}</div>
          `;
        }
      } else {
        // Show avatar instead of video
        if (div.querySelector('video')) {
          div.innerHTML = `
            <div class="voice-participant-avatar" style="width: 80px; height: 80px; border-radius: 50%; overflow: hidden; background: ${getRoleColor(userData.role || 'Member')}; display: flex; align-items: center; justify-content: center; font-size: 32px; color: white;">
              ${userData.avatar ? `<img src="${userData.avatar}" style="width: 100%; height: 100%; object-fit: cover;">` : (userData.username ? userData.username.charAt(0).toUpperCase() : '?')}
            </div>
            <div class="voice-participant-name" style="margin-top: 4px;">${userData.username || 'Unknown'}</div>
          `;
        }
      }
      
      // Only append if new
      if (!div.parentElement) {
        elements.voiceUsersDisplay.appendChild(div);
      }
      
      // Establish connection if new
      if (!peerConnections[uid]) {
        establishPeerConnection(uid);
      }
    });
  });
}
900
function joinVoiceChannel(channelName) {
  console.log('[Voice Channel] Joining:', channelName);
  
  if (!currentServer) {
    console.error('[Voice Channel] No server');
    return;
  }

  // Leave current if in one
  if (inVoiceChannel) {
    disconnectVoice();
  }

  const constraints = { 
    audio: true, 
    video: isVideoEnabled ? { width: 640, height: 360 } : false
  };
  
  navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
      console.log('[Voice Channel] Got media stream');
      
      currentVoiceChannel = channelName;
      inVoiceChannel = true;

      if (isVideoEnabled) {
        videoStream = stream;
        // Extract audio track separately
        const audioTrack = stream.getAudioTracks()[0];
        if (audioTrack) {
          localStream = new MediaStream([audioTrack]);
        }
        // Start video display
        startVideo();
      } else {
        localStream = stream;
        videoStream = null;
      }

      // Add to channel users
      db.ref(`servers/${currentServer}/voiceChannels/${channelName}/users/${currentUser.uid}`).set({
        username: userProfile.username,
        avatar: userProfile.avatar,
        muted: isMuted,
        deafened: isDeafened,
        videoEnabled: isVideoEnabled,
        joinedAt: Date.now()
      });

      // Update UI
      elements.voicePanel.classList.add('active');
      elements.voiceChannelName.textContent = channelName;
      currentChannel = channelName;
      currentChannelType = 'voice';

      // Setup listeners
      setupVoiceUsersListener(channelName);
      loadMemberList();
      updateUserVoiceStatus();
      
      showToast(`Connected to ${channelName}`, 'success');
    })
    .catch(error => {
      console.error('[Voice Channel] Media error:', error);
      showToast('Microphone/Camera access required', 'error');
      isVideoEnabled = false;
      updateUserVoiceStatus();
    });
}
1000
function toggleVideo() {
  isVideoEnabled = !isVideoEnabled;
  
  if (isVideoEnabled) {
    // Turning video ON
    if (inVoiceChannel) {
      // Already in voice, need to get video and add to stream
      navigator.mediaDevices.getUserMedia({ 
        video: { width: 640, height: 360, facingMode: "user" } 
      })
        .then(stream => {
          videoStream = stream;
          
          // If we don't have audio yet, get it too
          if (!localStream) {
            return navigator.mediaDevices.getUserMedia({ audio: true })
              .then(audioStream => {
                localStream = audioStream;
                // Combine tracks
                stream.getTracks().forEach(t => {
                  if (t.kind === 'video') {
                    localStream.addTrack(t);
                  }
                });
              });
          }
          
          // Add video track to localStream for consistency
          const videoTrack = stream.getVideoTracks()[0];
          if (videoTrack && localStream) {
            localStream.addTrack(videoTrack);
          }
        })
        .then(() => {
          // Show local video
          startVideo();
          
          // Add to existing peer connections
          if (videoStream) {
            const videoTrack = videoStream.getVideoTracks()[0];
            Object.keys(peerConnections).forEach(otherUid => {
              const pc = peerConnections[otherUid];
              if (pc && videoTrack) {
                try {
                  pc.addTrack(videoTrack, videoStream);
                } catch (e) {
                  console.error('Error adding video track:', e);
                }
              }
            });
          }
          
          // Update database
          db.ref(`servers/${currentServer}/voiceChannels/${currentVoiceChannel}/users/${currentUser.uid}`).update({
            videoEnabled: true
          });
          
          updateUserVoiceStatus();
        })
        .catch(error => {
          console.error('[Video] Error enabling:', error);
          isVideoEnabled = false;
          showToast('Camera access denied', 'error');
          updateUserVoiceStatus();
        });
    } else {
      // Not in voice, just toggle flag
      updateUserVoiceStatus();
    }
  } else {
    // Turning video OFF
    stopVideo();
    
    if (inVoiceChannel && currentServer && currentVoiceChannel) {
      db.ref(`servers/${currentServer}/voiceChannels/${currentVoiceChannel}/users/${currentUser.uid}`).update({
        videoEnabled: false
      });
    }
    
    updateUserVoiceStatus();
  }
}